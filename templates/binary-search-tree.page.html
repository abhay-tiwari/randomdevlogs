{{template "base" .}}

{{ define "meta" }}

{{ end }}

{{ define "css" }}
<style>
.tree {
  height: 250px;
  width: 400px;
  margin-left: auto;
  margin-right: auto;
}

.tree-level {
  margin-top: 2.5rem;
  margin-left: auto;
  margin-right: auto;
  position: relative;
}

.tree__level-1 {
  height: 50px;
}

.tree__level-2 {
  height: 50px;
}

.tree__level-3 {
  height: 50px;
}

.node {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  border: 1px solid #FF6B6B;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #FF6B6B;
  position: absolute;
  transition: all 0.25s;
}

.edge-1 {
  position: absolute;
}

.edge-2 {
  position: absolute;
}

.one {
  left: calc(50% - 25px);
}

.one .edge-1 {
  height: 85.5px;
  width: 1px;
  background: #FF6B6B;
  transform: rotate(45deg);
  top: 49%;
  left: -59%;
}

.one .edge-2 {
  height: 85.5px;
  width: 1px;
  background: #FF6B6B;
  transform: rotate(135deg);
  top: 49%;
  left: 157%;
}

.two {
  left: calc(25% - 25px);
}

.two .edge-1 {
  height: 69.5px;
  width: 1px;
  background: #FF6B6B;
  transform: rotate(45deg);
  top: 66%;
  left: -37%;
}

.two .edge-2 {
  height: 61.5px;
  width: 1px;
  background: #FF6B6B;
  transform: rotate(135deg);
  top: 77%;
  left: 115%;
}

.three .edge-1 {
  height: 60.5px;
  width: 1px;
  background: #FF6B6B;
  transform: rotate(45deg);
  top: 79%;
  left: -18%;
}

.three .edge-2 {
  height: 68.5px;
  width: 1px;
  background: #FF6B6B;
  transform: rotate(135deg);
  top: 70%;
  left: 132%;
}

.edge-1:after {
  content: '';
  height: 0;
  top: 0;
  left: 0;
  width: 1px;
  position: absolute;
  background: #FFF;
  transition: all 0.25s;
}

.edge-2:after {
  content: '';
  height: 0;
  bottom: 0;
  width: 1px;
  position: absolute;
  background: #FFF;
  transition: all 0.25s;
}

.three {
  left: calc(75% - 25px);
}

.four {
  left: 0;
}

.five {
  left: 32%;
}

.six {
  left: 55%;
}

.seven {
  left: calc(100% - 50px);
}
</style>
{{ end }}

{{ define "content" }}
<div id="binary-search-tree" class="binary-search-tree text-white mt-5 blog-container">
  <section class="binary-search-tree__introduction">
    <h2>What is Binary Search Tree?</h2>
    <p>Binary Search Tree is a fundamental data structure in computer science that wide range of applications such as search alogithms and data manipulations. In this blog, we will learn about concept of Binary Search Tree and its properties, operations and importance of solving real world problems.</p>
    <p>Binary Search Tree is a Binary Tree that has following properties.</p>

    <ul>
      <li>All nodes in left subtree of node have value less than value of node.</li>
      <li>All nodes in right subtree of node has value greater than value of node.</li>
      <li>Left and Right Subtree are Binary Search Trees.</li>
    </ul>

    <p>These properties makes Binary Search Tree useful in various use cases such as searching, insertion and deletion of data.</p>

    <p>The Example of Binary Search Tree is as follows.</p>
    <div class="tree">
     <div class="tree-level tree__level-1">
      <div class="node one">
        4
        <div class="edge-1"></div>
        <div class="edge-2"></div>
      </div>
     </div> 
     <div class="tree-level tree__level-2">
      <div class="node two">
        2
        <div class="edge-1"></div>
        <div class="edge-2"></div>
      </div>
      <div class="node three">
        5
        <div class="edge-2"></div>
      </div>
     </div> 
     <div class="tree-level tree__level-3">
      <div class="node four">
        1
      </div>
      <div class="node five">
        3
      </div>
      <div class="node seven">
        6
      </div>
     </div> 
    </div>
  </section> 

  <section class="binary-search-tree__operations mt-5">
    <h2>Operations on Binary Search Tree</h2>
    <p>Most common operations on Binary Search Tree are as follows.</p>

    <h3>1. Insertion</h3>
    <p>To insert a new element into Binary Search Tree(BST), you traverse starting at root and follow left or right child nodes based on the value of element being inserted. This process continues until you find empty spot of insertion.</p>

    <h3>2. Searching</h3>
    <p>Searching for an element in Binary Search Tree (BST) is efficient due to the Binary Search Tree properties. You start at the root and compare the target value with current node's value. Based on the comparison, you move left or right subtree until you either find the element or reach a leaf node, indicating the element in not present in tree.</p>

    <h3>3. Deletion</h3>
    <p>Deleting a node from a BST involves three cases: a) Node with no children, b) Node with one child, and c) Node with two children. The process can be a bit complex in the case of two children, as it requires finding the in-order predecessor or successor to replace the node.</p>

    <h3>4. Traversal</h3>
    <p>There are three common methods for traversing a BST: <a href="/data-structures/recursive-inorder-traversal">Inorder Traversal</a>, <a href="/data-structures/recursive-preorder-traversal">Preorder Traversal</a> and <a href="/data-structures/recursive-postorder-traversal">Postorder Traversal</a>. These methods determine the sequence in which nodes are visited.</p>
  </section>

  <section class="binary-search-tree___implementation mt-5">
    <h2>C++ Code to Check if a Binary Tree is a Binary Search Tree</h2>
    <p>C++ code to check if a Binary Tree is a Binary Search Tree is as follows</p>

    <div class="binary-search-tree__code-block code-block">
      <pre>
      <code>#include&lt;iostream&gt;&#13;#include&lt;limits.h&gt;&#13;&#13;using namespace std;&#13;&#13;// class definition of tree node.&#13;class TreeNode {&#13;public:&#13;  int val;&#13;  TreeNode *left;&#13;  TreeNode *right;&#13;  TreeNode* ansNode = NULL;&#13;&#13;  TreeNode(int val) {&#13;    this -&gt; val = val;&#13;  }&#13;};&#13;&#13;// function to get max value in tree.&#13;int maxValue(TreeNode* node) {&#13;  if(node == NULL) {&#13;    return INT_MIN;&#13;  }&#13;&#13;  int value = node -&gt; val;&#13;&#13;  int leftMax = maxValue(node -&gt; left);&#13;  int rightMax = maxValue(node -&gt; right);&#13;&#13;  return max(value, max(leftMax, rightMax));&#13;}&#13;&#13;&#13;// function to get min value in tree.&#13;int minValue(TreeNode* node) {&#13;  if(node == NULL) {&#13;    return INT_MAX;&#13;  }&#13;&#13;  int value = node -&gt; val;&#13;&#13;  int leftMin = minValue(node -&gt; left);&#13;  int rightMin = minValue(node -&gt; right);&#13;&#13;  return min(value, min(leftMin, rightMin));&#13;}&#13;&#13;bool isBST(TreeNode* node) {&#13;  if(node == NULL) {&#13;    return true;&#13;  }&#13;&#13;  int value = node -&gt; val;&#13;&#13;&#13;  // if max value in left substree is greater than current node value&#13;  // tree is not BST (Binary Search Tree)&#13;  if(node -&gt; left != NULL &amp;&amp; maxValue(node -&gt; left) &gt;= value) {&#13;    return false;&#13;  }&#13;&#13;  // if min value in right substree is less than current node value&#13;  // tree is not BST(Binary Search Tree).&#13;  if(node -&gt; right != NULL &amp;&amp; minValue(node -&gt; right) &lt;= value) {&#13;    return false;&#13;  } &#13;&#13;  // If left and right subtree is not BST, tree is not BST.&#13;  if(!isBST(node -&gt; left) || !isBST(node -&gt; right)) {&#13;    return false;&#13;  }&#13;  &#13;  return true;&#13;}&#13;&#13;&#13;int main() {&#13;&#13;  TreeNode* one = new TreeNode(1);&#13;  TreeNode* two = new TreeNode(2);&#13;  TreeNode* three = new TreeNode(3);&#13;  TreeNode* four = new TreeNode(4);&#13;  TreeNode* five = new TreeNode(5);&#13;  TreeNode* six = new TreeNode(6);&#13;&#13;  // define four as tree root.&#13;  TreeNode* root = four;&#13;&#13;  root -&gt; left = two;&#13;  root -&gt; right = five;&#13;&#13;  two -&gt; left = one;&#13;  two -&gt; right = three;&#13;  &#13;  five -&gt; right = six;&#13; &#13;  if(isBST(root) == true) {&#13;    cout &lt;&lt; &quot;This Binary Tree is Binary Search Tree.&quot; &lt;&lt; endl;&#13;  }&#13;  else {&#13;    cout &lt;&lt; &quot;This Binary Tree is not Binary Search Tree&quot; &lt;&lt; endl;&#13;  }&#13;  return 0;&#13;}</code>
      </pre>
    <button class="btn copy-btn" onclick="onCopyButtonClick(this)">
          <i class="fa-regular fa-copy"></i>
          <i class="fa-solid fa-check"></i>
    </button>
    </div>
  </section>

  <section class="binary-search-tree___applications mt-5">
    <h2>Applications of Binary Search Tree</h2>
    <p>Applications of Binary Search Tree are as follows.</p>

    <h3>1. Searching and Retrieval</h3>
    <p>As mentioned earlier, BSTs excel in searching and retrieval tasks due to their efficient structure.</p>

    <h3>2. Sorting</h3>
    <p>BSTs can be used to perform in-place sorting, such as the in-order traversal that results in a sorted list.</p>

    <h3>3. Symbol Tables</h3>
    <p>BSTs can be employed in implementing symbol tables for storing key-value pairs, which are essential in databases and dictionaries.</p>

    <h3>4. Auto-Completion</h3>
    <p>BSTs are used in auto-completion algorithms for search engines and text editors.</p>

    <h3>5. File Systems</h3>
    <p>BSTs are the basis for many file system data structures, helping manage directory structures and file retrieval.</p>
  </section>

  <section class="binary-search-tree__conclusion">
    <h2>Conclusion</h2>
    <p>Binary Search Trees are fundamental data structures with various applications in computer science and software development. Their structure and the efficiency of their operations make them a valuable tool for solving various real-world problems. Understanding BSTs is a crucial step in becoming a proficient programmer, as it provides a strong foundation for more advanced data structures and algorithms.</p>
    <p>Thanks for Reading and have a nice day.</p>
  </section>
</div>
{{ end }}

